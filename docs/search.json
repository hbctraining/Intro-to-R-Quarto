[
  {
    "objectID": "04_introR_packages.html",
    "href": "04_introR_packages.html",
    "title": "Packages and libraries",
    "section": "",
    "text": "Approximate time: 25 min"
  },
  {
    "objectID": "04_introR_packages.html#learning-objectives",
    "href": "04_introR_packages.html#learning-objectives",
    "title": "Packages and libraries",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nExplain different ways to install external R packages\nDemonstrate how to load a library and how to find functions specific to a package"
  },
  {
    "objectID": "04_introR_packages.html#packages-and-libraries",
    "href": "04_introR_packages.html#packages-and-libraries",
    "title": "Packages and libraries",
    "section": "Packages and Libraries",
    "text": "Packages and Libraries\nPackages are collections of R functions, data, and compiled code in a well-defined format, created to add specific functionality. There are 10,000+ user contributed packages and growing.\nThere are a set of standard (or base) packages which are considered part of the R source code and automatically available as part of your R installation. Base packages contain the basic functions that allow R to work, and enable standard statistical and graphical functions on datasets; for example, all of the functions that we have been using so far in our examples.\nThe directories in R where the packages are stored are called the libraries. The terms package and library are sometimes used synonymously and there has been discussion amongst the community to resolve this. It is somewhat counter-intuitive to load a package using the library() function and so you can see how confusion can arise.\nYou can check what libraries are loaded in your current R session by typing into the console:\n\nsessionInfo() #Print version information about R, the OS and attached or loaded packages\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sonoma 14.3.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.4.1    fastmap_1.2.0     cli_3.6.3        \n [5] tools_4.4.1       htmltools_0.5.8.1 rstudioapi_0.16.0 yaml_2.3.10      \n [9] rmarkdown_2.28    knitr_1.48        jsonlite_1.8.9    xfun_0.47        \n[13] digest_0.6.37     rlang_1.1.4       evaluate_1.0.0   \n\n# OR\n\nsearch() #Gives a list of attached packages\n\n[1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n[4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n[7] \"package:methods\"   \"Autoloads\"         \"package:base\"     \n\n\nPreviously we have introduced you to functions from the standard base packages. However, the more you work with R, you will come to realize that there is a cornucopia of R packages that offer a wide variety of functionality. To use additional packages will require installation. Many packages can be installed from the CRAN or Bioconductor repositories.\n\n\n\n\n\n\nHelpful tips for package installations\n\n\n\n\nPackage names are case sensitive!\nAt any point (especially if you’ve used R/Bioconductor in the past), in the console R may ask you if you want to “update any old packages by asking Update all/some/none? [a/s/n]:”. If you see this, type “a” at the prompt and hit Enter to update any old packages. Updating packages can sometimes take awhile to run. If you are short on time, you can choose “n” and proceed. Without updating, you run the risk of conflicts between your old packages and the ones from your updated R version later down the road.\nIf you see a message in your console along the lines of “binary version available but the source version is later”, followed by a question, “Do you want to install from sources the package which needs compilation? y/n”, type n for no, and hit enter.\n\n\n\n\nPackage installation from CRAN\nCRAN is a repository where the latest downloads of R (and legacy versions) are found in addition to source code for thousands of different user contributed R packages.\n\n\n\nPackages for R can be installed from the CRAN package repository using the install.packages function. This function will download the source code from on the CRAN mirrors and install the package (and any dependencies) locally on your computer.\nAn example is given below for the ggplot2 package that will be required for some plots we will create later on. Run this code to install ggplot2.\n\ninstall.packages(\"ggplot2\")\n\n\nThe downloaded binary packages are in\n    /var/folders/qb/pppkhh997tl5mc721j34g6qh0000gn/T//RtmpzXvuph/downloaded_packages\n\n\n\n\nPackage installation from Bioconductor\nAlternatively, packages can also be installed from Bioconductor, another repository of packages which provides tools for the analysis and comprehension of high-throughput genomic data. These packages includes (but is not limited to) tools for performing statistical analysis, annotation packages, and accessing public datasets.\n\n\n\nThere are many packages that are available in CRAN and Bioconductor, but there are also packages that are specific to one repository. Generally, you can find out this information with a Google search or by trial and error.\nTo install from Bioconductor, you will first need to install BiocManager. This only needs to be done once ever for your R installation.\n\n# DO NOT RUN THIS!\ninstall.packages(\"BiocManager\")\n\nNow you can use the install() function from the BiocManager package to install a package by providing the name in quotations.\nHere we have the code to install ggplot2, through Bioconductor:\n\n# DO NOT RUN THIS!\nBiocManager::install(\"ggplot2\")\n\n\nThe code above may not be familiar to you - it is essentially using a new operator, a double colon :: to execute a function from a particular package. This is the syntax: package::function_name().\n\n\n\nPackage installation from source\nFinally, R packages can also be installed from source. This is useful when you do not have an internet connection (and have the source files locally), since the other two methods are retrieving the source files from remote sites.\nTo install from source, we use the same install.packages function but we have additional arguments that provide specifications to change from defaults:\n\n# DO NOT RUN THIS!\ninstall.packages(\"~/Downloads/ggplot2_1.0.1.tar.gz\", type=\"source\", repos=NULL)\n\n\n\nLoading libraries\nOnce you have the package installed, you can load the library into your R session for use. Any of the functions that are specific to that package will be available for you to use by simply calling the function as you would for any of the base functions. Note that quotations are not required here.\n\nlibrary(ggplot2)\n\nYou can also check what is loaded in your current environment by using sessionInfo() or search() and you should see your package listed as:\nother attached packages:\n[1] ggplot2_2.0.0\nIn this case there are several other packages that were also loaded along with ggplot2.\nWe only need to install a package once on our computer. However, to use the package, we need to load the library every time we start a new R/RStudio environment. You can think of this as installing a bulb versus turning on the light.\n\n\n\nAnalogy and image credit to Dianne Cook of Monash University.\n\n\nFinding functions specific to a package\nThis is your first time using ggplot2, how do you know where to start and what functions are available to you? One way to do this, is by using the Package tab in RStudio. If you click on the tab, you will see listed all packages that you have installed. For those libraries that you have loaded, you will see a blue checkmark in the box next to it. Scroll down to ggplot2 in your list:\n\n\n\nIf your library is successfully loaded you will see the box checked, as in the screenshot above. Now, if you click on ggplot2 RStudio will open up the help pages and you can scroll through.\nAn alternative is to find the help manual online, which can be less technical and sometimes easier to follow. For example, this website is much more comprehensive for ggplot2 and is the result of a Google search. Many of the Bioconductor packages also have very helpful vignettes that include comprehensive tutorials with mock data that you can work with.\nIf you can’t find what you are looking for, you can use the rdocumention.org website that search through the help files across all packages available.\n\n\n\n\n\n\nExercises\n\n\n\n\nThe ggplot2 package is part of the tidyverse suite of integrated packages which was designed to work together to make common data science operations more user-friendly. We will be using the tidyverse suite in later lessons, and so let’s install it. NOTE: This suite of packages is only available in CRAN."
  },
  {
    "objectID": "02_introR-syntax-and-data-structures.html",
    "href": "02_introR-syntax-and-data-structures.html",
    "title": "R Syntax and Data Structures",
    "section": "",
    "text": "Approximate time: 70 min"
  },
  {
    "objectID": "02_introR-syntax-and-data-structures.html#learning-objectives",
    "href": "02_introR-syntax-and-data-structures.html#learning-objectives",
    "title": "R Syntax and Data Structures",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe frequently-used data types in R.\nConstruct data structures to store data."
  },
  {
    "objectID": "02_introR-syntax-and-data-structures.html#data-types",
    "href": "02_introR-syntax-and-data-structures.html#data-types",
    "title": "R Syntax and Data Structures",
    "section": "Data Types",
    "text": "Data Types\nVariables can contain values of specific types within R. The six data types that R uses include:\n\n\"numeric\" for any numerical value, including whole numbers and decimals. This is the most common data type for performing mathematical operations.\n\"character\" for text values, denoted by using quotes (““) around value. For instance, while 5 is a numeric value, if you were to put quotation marks around it, it would turn into a character value, and you could no longer use it for mathematical operations. Single or double quotes both work, as long as the same type is used at the beginning and end of the character value.\n\"integer\" for whole numbers (e.g., 2L, the L indicates to R that it’s an integer). It behaves similar to the numeric data type for most tasks or functions; however, it takes up less storage space than numeric data, so often tools will output integers if the data is known to be comprised of whole numbers. Just know that integers behave similarly to numeric values. If you wanted to create your own, you could do so by providing the whole number, followed by an upper-case L.\n\"logical\" for TRUE and FALSE (the Boolean data type). The logical data type can be specified using four values, TRUE in all capital letters, FALSE in all capital letters, a single capital T or a single capital F.\n\"complex\" to represent complex numbers with real and imaginary parts (e.g., 1+4i) and that’s all we’re going to say about them\n\"raw\" that we won’t discuss further\n\nThe table below provides examples of each of the commonly used data types:\n\n\n\nData Type\nExamples\n\n\n\n\nNumeric:\n1, 1.5, 20, pi\n\n\nCharacter:\n“anytext”, “5”, “TRUE”\n\n\nInteger:\n2L, 500L, -17L\n\n\nLogical:\nTRUE, FALSE, T, F\n\n\n\nThe type of data will determine what you can do with it. For example, if you want to perform mathematical operations, then your data type cannot be character or logical. Whereas if you want to search for a word or pattern in your data, then you data should be of the character data type. The task or function being performed on the data will determine what type of data can be used."
  },
  {
    "objectID": "02_introR-syntax-and-data-structures.html#data-structures",
    "href": "02_introR-syntax-and-data-structures.html#data-structures",
    "title": "R Syntax and Data Structures",
    "section": "Data Structures",
    "text": "Data Structures\nWe know that variables are like buckets, and so far we have seen that bucket filled with a single value. Even when number was created, the result of the mathematical operation was a single value. Variables can store more than just a single value, they can store a multitude of different data structures. These include, but are not limited to, vectors (c), factors (factor), matrices (matrix), data frames (data.frame) and lists (list).\n\nVectors\nA vector is the most common and basic data structure in R, and is pretty much the workhorse of R. It’s basically just a collection of values, mainly either numbers,\n\n\n\nnumeric vector\n\n\nor characters,\n\n\n\ncharacter vector\n\n\nor logical values,\n\n\n\nlogical vector\n\n\nNote that all values in a vector must be of the same data type. If you try to create a vector with more than a single data type, R will try to coerce it into a single data type.\nFor example, if you were to try to create the following vector:\n\n\n\nmixed vector\n\n\nR will coerce it into:\n\n\n\nThe analogy for a vector is that your bucket now has different compartments; these compartments in a vector are called elements.\nEach element contains a single value, and there is no limit to how many elements you can have. A vector is assigned to a single variable, because regardless of how many elements it contains, in the end it is still a single entity (bucket).\nLet’s create a vector of genome lengths and assign it to a variable called glengths.\nEach element of this vector contains a single numeric value, and three values will be combined together into a vector using c() (the combine function). All of the values are put within the parentheses and separated with a comma.\n\n# Create a numeric vector and store the vector as a variable called 'glengths'\nglengths &lt;- c(4.6, 3000, 50000)\nglengths\n\n[1]     4.6  3000.0 50000.0\n\n\nNote your environment shows the glengths variable is numeric (num) and tells you the glengths vector starts at element 1 and ends at element 3 (i.e. your vector contains 3 values) as denoted by the [1:3].\nA vector can also contain characters. Create another vector called species with three elements, where each element corresponds with the genome sizes vector (in Mb).\n\n# Create a character vector and store the vector as a variable called 'species'\nspecies &lt;- c(\"ecoli\", \"human\", \"corn\")\nspecies\n\n[1] \"ecoli\" \"human\" \"corn\" \n\n\nWhat do you think would happen if we forgot to put quotations around one of the values? Let’s test it out with corn.\n\n# Forget to put quotes around corn\nspecies &lt;- c(\"ecoli\", \"human\", corn)\n\n\n\n\n\n\n\nWarning\n\n\n\nError: object ‘corn’ not found\n\n\nNote that RStudio is quite helpful in color-coding the various data types. We can see that our numeric values are blue, the character values are green, and if we forget to surround corn with quotes, it’s black. What does this mean? Let’s try to run this code.\nWhen we try to run this code we get an error specifying that object ‘corn’ is not found. What this means is that R is looking for an object or variable in my Environment called ‘corn’, and when it doesn’t find it, it returns an error. If we had a character vector called ‘corn’ in our Environment, then it would combine the contents of the ‘corn’ vector with the values “ecoli” and “human”.\nSince we only want to add the value “corn” to our vector, we need to re-run the code with the quotation marks surrounding corn. A quick way to add quotes to both ends of a word in RStudio is to highlight the word, then press the quote key.\n\n# Create a character vector and store the vector as a variable called 'species'\nspecies &lt;- c(\"ecoli\", \"human\", \"corn\")\n\n\n\n\n\n\n\nExercises\n\n\n\n\nTry to create a vector of numeric and character values by combining the two vectors that we just created (glengths and species). Assign this combined vector to a new variable called combined. Hint: you will need to use the combine c() function to do this. Print the combined vector in the console, what looks different compared to the original vectors?\n\n\n\n\n\nFactors\nA factor is a special type of vector that is used to store categorical data. Each unique category is referred to as a factor level (i.e. category = level). Factors are built on top of integer vectors such that each factor level is assigned an integer value, creating value-label pairs.\nFor instance, if we have four animals and the first animal is female, the second and third are male, and the fourth is female, we could create a factor that appears like a vector, but has integer values stored under-the-hood. The integer value assigned is a one for females and a two for males. The numbers are assigned in alphabetical order, so because the f- in females comes before the m- in males in the alphabet, females get assigned a one and males a two. In later lessons we will show you how you could change these assignments.\n\n\n\nfactors\n\n\nLet’s create a factor vector and explore a bit more. We’ll start by creating a character vector describing three different levels of expression. Perhaps the first value represents expression in mouse1, the second value represents expression in mouse2, and so on and so forth:\n\n# Create a character vector and store the vector as a variable called 'expression'\nexpression &lt;- c(\"low\", \"high\", \"medium\", \"high\", \"low\", \"medium\", \"high\")\n\nNow we can convert this character vector into a factor using the factor() function:\n\n# Turn 'expression' vector into a factor\nexpression &lt;- factor(expression)\n\nSo, what exactly happened when we applied the factor() function?\n\n\n\nfactor_new\n\n\nThe expression vector is categorical, in that all the values in the vector belong to a set of categories; in this case, the categories are low, medium, and high. By turning the expression vector into a factor, the categories are assigned integers alphabetically, with high=1, low=2, medium=3. This in effect assigns the different factor levels. You can view the newly created factor variable and the levels in the Environment window.\n\n\n\nFactor variables in environment\n\n\nSo now that we have an idea of what factors are, when would you ever want to use them?\nFactors are extremely valuable for many operations often performed in R. For instance, factors can give order to values with no intrinsic order. In the previous ‘expression’ vector, if I wanted the low category to be less than the medium category, then we could do this using factors. Also, factors are necessary for many statistical methods. For example, descriptive statistics can be obtained for character vectors if you have the categorical information stored as a factor. Also, if you want to denote which category is your base level for a statistical comparison, then you would need to have your category variable stored as a factor with the base level assigned to 1. Anytime that it is helpful to have the categories thought of as groups in an analysis, the factor function makes this possible. For instance, if you want to color your plots by treatment type, then you would need the treatment variable to be a factor.\n\n\n\n\n\n\nExercises\n\n\n\nLet’s say that in our experimental analyses, we are working with three different sets of cells: normal, cells knocked out for geneA (a very exciting gene), and cells overexpressing geneA. We have three replicates for each celltype.\n\nCreate a vector named samplegroup with nine elements: 3 control (“CTL”) values, 3 knock-out (“KO”) values, and 3 over-expressing (“OE”) values.\nTurn samplegroup into a factor data structure.\n\n\n\n\n\nMatrix\nA matrix in R is a collection of vectors of same length and identical datatype. Vectors can be combined as columns in the matrix or by row, to create a 2-dimensional structure.\n\n\n\nmatrix\n\n\nMatrices are used commonly as part of the mathematical machinery of statistics. They are usually of numeric datatype and used in computational algorithms to serve as a checkpoint. For example, if input data is not of identical data type (numeric, character, etc.), the matrix() function will throw an error and stop any downstream code execution.\n\n\nData Frame\nA data.frame is the de facto data structure for most tabular data and what we use for statistics and plotting. A data.frame is similar to a matrix in that it’s a collection of vectors of the same length and each vector represents a column. However, in a dataframe each vector can be of a different data type (e.g., characters, integers, factors). In the data frame pictured below, the first column is character, the second column is numeric, the third is character, and the fourth is logical.\n\n\n\ndataframe\n\n\nA data frame is the most common way of storing data in R, and if used systematically makes data analysis easier.\nWe can create a dataframe by bringing vectors together to form the columns. We do this using the data.frame() function, and giving the function the different vectors we would like to bind together. This function will only work for vectors of the same length.\n\n# Create a data frame and store it as a variable called 'df'\ndf &lt;- data.frame(species, glengths)\n\nWe can see that a new variable called df has been created in our Environment within a new section called Data. In the Environment, it specifies that df has 3 observations of 2 variables. What does that mean? In R, rows always come first, so it means that df has 3 rows and 2 columns. We can get additional information if we click on the blue circle with the white triangle in the middle next to df. It will display information about each of the columns in the data frame, giving information about what the data type is of each of the columns and the first few values of those columns.\nAnother handy feature in RStudio is that if we hover the cursor over the variable name in the Environment, df, it will turn into a pointing finger. If you click on df, it will open the data frame as it’s own tab next to the script editor. We can explore the table interactively within this window. To close, just click on the X on the tab.\nAs with any variable, we can print the values stored inside to the console if we type the variable’s name and run.\n\ndf\n\n  species glengths\n1   ecoli      4.6\n2   human   3000.0\n3    corn  50000.0\n\n\n\n\n\n\n\n\nExercises\n\n\n\n\nCreate a data frame called favorite_books with the following vectors as columns:\n\n\ntitles &lt;- c(\"Catch-22\", \"Pride and Prejudice\", \"Nineteen Eighty Four\")\npages &lt;- c(453, 432, 328)\n\n\n\n\n\nLists\nLists are a data structure in R that can be perhaps a bit daunting at first, but soon become amazingly useful. A list is a data structure that can hold any number of any types of other data structures.\n\n\n\nlist\n\n\nIf you have variables of different data structures you wish to combine, you can put all of those into one list object by using the list() function and placing all the items you wish to combine within parentheses:\n\nlist1 &lt;- list(species, df, number)\n\nWe see list1 appear within the Data section of our environment as a list of 3 components or variables. If we click on the blue circle with a triangle in the middle, it’s not quite as interpretable as it was for data frames.\nEssentially, each component is preceded by a colon. The first colon give the species vector, the second colon precedes the df data frame, with the dollar signs indicating the different columns, the last colon gives the single value, number.\nIf I click on list1, it opens a tab where you can explore the contents a bit more, but it’s still not super intuitive. The easiest way to view small lists is to print to the console.\nLet’s type list1 and print to the console by running it.\n\nlist1\n\n[[1]]\n[1] \"ecoli\" \"human\" \"corn\" \n\n[[2]]\n  species glengths\n1   ecoli      4.6\n2   human   3000.0\n3    corn  50000.0\n\n[[3]]\n[1] 8\n\n\nThere are three components corresponding to the three different variables we passed in, and what you see is that structure of each is retained. Each component of a list is referenced based on the number position. We will talk more about how to inspect and manipulate components of lists in later lessons.\n\n\n\n\n\n\nExercises\n\n\n\n\nCreate a list called list2 containing species, glengths, and number.\n\n\n\nNow that we know what lists are, why would we ever want to use them? When getting started with R, you will most likely encounter lists with different tools or functions that you use. Oftentimes a tool will need a list as input, so that all the information needed to run the tool is present in a single variable. Sometimes a tool will output a list when working through an analysis. Knowing how to work with them and extract necessary information will be critically important.\nAs you become more comfortable with R, you will find yourself using lists more often. One common use of lists is to make iterative processes more efficient. For example, let’s say you had multiple data frames containing the same weather information from different cities throughout North America. You wanted to perform the same task on each of the data frames, but that would take a long time to do individually. Instead you could create a list where each data frame is a component of the list. Then, you could perform the task on the list instead, which would be applied to each of the components."
  },
  {
    "objectID": "03_introR-functions-and-arguments.html",
    "href": "03_introR-functions-and-arguments.html",
    "title": "Functions in R",
    "section": "",
    "text": "Approximate time: 30 min"
  },
  {
    "objectID": "03_introR-functions-and-arguments.html#learning-objectives",
    "href": "03_introR-functions-and-arguments.html#learning-objectives",
    "title": "Functions in R",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe and utilize functions in R.\nModify default behavior of a function using arguments.\nIdentify R-specific sources of obtaining more information about functions.\nDemonstrate how to create user-defined functions in R"
  },
  {
    "objectID": "03_introR-functions-and-arguments.html#functions-and-their-arguments",
    "href": "03_introR-functions-and-arguments.html#functions-and-their-arguments",
    "title": "Functions in R",
    "section": "Functions and their arguments",
    "text": "Functions and their arguments\n\nWhat are functions?\nA key feature of R is functions. Functions are “self contained” modules of code that accomplish a specific task. Functions usually take in some sort of data structure (value, vector, dataframe etc.), process it, and return a result.\nThe general usage for a function is the name of the function followed by parentheses:\n\nfunction_name(input)\n\nThe input(s) are called arguments, which can include:\n\nthe physical object (any data structure) on which the function carries out a task\nspecifications that alter the way the function operates (e.g. options)\n\nNot all functions take arguments, for example:\n\ngetwd()\n\n[1] \"/Users/nos491/Desktop/intro_r_rmd/lessons\"\n\n\nHowever, most functions can take several arguments. If you don’t specify a required argument when calling the function, you will either receive an error or the function will fall back on using a default.\nThe defaults represent standard values that the author of the function specified as being “good enough in standard cases”. An example would be what symbol to use in a plot. However, if you want something specific, simply change the argument yourself with a value of your choice.\n\n\nBasic functions\nWe have already used a few examples of basic functions in the previous lessons i.e getwd(), c(), and factor(). These functions are available as part of R’s built in capabilities, and we will explore a few more of these base functions below.\nLet’s revisit a function that we have used previously to combine data c() into vectors. The arguments it takes is a collection of numbers, characters or strings (separated by a comma). The c() function performs the task of combining the numbers or characters into a single vector. You can also use the function to add elements to an existing vector:\n\nglengths &lt;- c(glengths, 90) # adding at the end \nglengths &lt;- c(30, glengths) # adding at the beginning\nglengths\n\n[1]    30.0     4.6  3000.0 50000.0    90.0\n\n\nWhat happens here is that we take the original vector glengths (containing three elements), and we are adding another item to either end. We can do this over and over again to build a vector or a dataset.\nSince R is used for statistical computing, many of the base functions involve mathematical operations. One example would be the function sqrt(). The input/argument must be a number, and the output is the square root of that number. Let’s try finding the square root of 81:\n\nsqrt(81)\n\n[1] 9\n\n\nNow what would happen if we called the function (e.g. ran the function), on a vector of values instead of a single value?\n\nsqrt(glengths)\n\n[1]   5.477226   2.144761  54.772256 223.606798   9.486833\n\n\nIn this case the task was performed on each individual value of the vector glengths and the respective results were displayed.\nLet’s try another function, this time using one that we can change some of the options (arguments that change the behavior of the function), for example round:\n\nround(3.14159)\n\n[1] 3\n\n\nWe can see that we get 3. That’s because the default is to round to the nearest whole number. What if we want a different number of significant digits? Let’s first learn how to find available arguments for a function.\n\n\nSeeking help on arguments for functions\nThe best way of finding out this information is to use the ? followed by the name of the function. Doing this will open up the help manual in the bottom right panel of RStudio that will provide a description of the function, usage, arguments, details, and examples:\n\n?round\n\nAlternatively, if you are familiar with the function but just need to remind yourself of the names of the arguments, you can use:\n\nargs(round)\n\nEven more useful is the example() function. This will allow you to run the examples section from the Online Help to see exactly how it works when executing the commands. Let’s try that for round():\n\nexample(\"round\")\n\nIn our example, we can change the number of digits returned by adding an argument. We can type digits=2 or however many we may want:\n\nround(3.14159, digits=2)\n\n[1] 3.14\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you provide the arguments in the exact same order as they are defined (in the help manual) you don’t have to name them:\n\nround(3.14159, 2)\n\n[1] 3.14\n\n\nHowever, it’s usually not recommended practice because it involves a lot of memorization. In addition, it makes your code difficult to read for your future self and others, especially if your code includes functions that are not commonly used. (It’s however OK to not include the names of the arguments for basic functions like mean, min, etc…). Another advantage of naming arguments, is that the order doesn’t matter. This is useful when a function has many arguments.\n\n\n\n\n\n\n\n\nExercises\n\n\n\n\nLet’s use base R function to calculate mean value of the glengths vector. You might need to search online to find what function can perform this task.\nCreate a new vector test &lt;- c(1, NA, 2, 3, NA, 4). Use the same base R function from exercise 1 (with addition of proper argument), and calculate mean value of the test vector. The output should be 2.5.\n\n\n\n\n\n\n\nNote\n\n\n\nIn R, missing values are represented by the symbol NA (not available). It’s a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. There are ways to ignore NA during statistical calculation, or to remove NA from the vector. If you want more information related to missing data or NA you can go to this page (please note that there are many advanced concepts on that page that have not been covered in class).\n\n\n\nAnother commonly used base function is sort(). Use this function to sort the glengths vector in descending order.\n\n\n\n\n\nUser-defined Functions\nOne of the great strengths of R is the user’s ability to add functions. Sometimes there is a small task (or series of tasks) you need done and you find yourself having to repeat it multiple times. In these types of situations, it can be helpful to create your own custom function. The structure of a function is given below:\n\nname_of_function &lt;- function(argument1, argument2) {\n    statements or code that does something\n    return(something)\n}\n\n\nFirst you give your function a name.\nThen you assign value to it, where the value is the function.\n\nWhen defining the function you will want to provide the list of arguments required (inputs and/or options to modify behaviour of the function), and wrapped between curly brackets place the tasks that are being executed on/using those arguments. The argument(s) can be any type of object (like a scalar, a matrix, a dataframe, a vector, a logical, etc), and it’s not necessary to define what it is in any way.\nFinally, you can “return” the value of the object from the function, meaning pass the value of it into the global environment. The important idea behind functions is that objects that are created within the function are local to the environment of the function – they don’t exist outside of the function.\nLet’s try creating a simple example function. This function will take in a numeric value as input, and return the squared value.\n\nsquare_it &lt;- function(x) {\n    square &lt;- x * x\n    return(square)\n}\n\nOnce you run the code, you should see a function named square_it in the Environment panel (located at the top right of Rstudio interface). Now, we can use this function as any other base R functions. We type out the name of the function, and inside the parentheses we provide a numeric value x:\n\nsquare_it(5)\n\n[1] 25\n\n\nPretty simple, right? In this case, we only had one line of code that was run, but in theory you could have many lines of code to get obtain the final results that you want to “return” to the user.\n\n\n\n\n\n\nNote\n\n\n\nDo I always have to return() something at the end of the function?\nIn the example above, we created a new variable called square inside the function, and then return the value of square. If you don’t use return(), by default R will return the value of the last line of code inside that function. That is to say, the following function will also work.\n\nsquare_it &lt;- function(x) {\n   x * x\n}\n\nHowever, we recommend always using return at the end of a function as the best practice.\n\n\nWe have only scratched the surface here when it comes to creating functions! We will revisit this in later lessons, but if interested you can also find more detailed information on this R-bloggers site, which is where we adapted this example from.\n\n\n\n\n\n\nExercises\n\n\n\n\nWrite a function called multiply_it, which takes two inputs: a numeric value x, and a numeric value y. The function will return the product of these two numeric values, which is x * y. For example, multiply_it(x=4, y=6) will return output 24."
  },
  {
    "objectID": "01_introR-R-and-RStudio.html",
    "href": "01_introR-R-and-RStudio.html",
    "title": "Introduction to R and RStudio",
    "section": "",
    "text": "Approximate time: 45 minutes"
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#learning-objectives",
    "href": "01_introR-R-and-RStudio.html#learning-objectives",
    "title": "Introduction to R and RStudio",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nDescribe what R and RStudio are.\nInteract with R using RStudio.\nFamiliarize various components of RStudio.\nEmploy variables in R."
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#what-is-r",
    "href": "01_introR-R-and-RStudio.html#what-is-r",
    "title": "Introduction to R and RStudio",
    "section": "What is R?",
    "text": "What is R?\nThe common misconception is that R is a programming language but in fact it is much more than that. Think of R as an environment for statistical computing and graphics, which brings together a number of features to provide powerful functionality.\nThe R environment combines:\n\nEffective handling of big data\nCollection of integrated tools\nGraphical facilities\nSimple and effective programming language"
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#why-use-r",
    "href": "01_introR-R-and-RStudio.html#why-use-r",
    "title": "Introduction to R and RStudio",
    "section": "Why use R?",
    "text": "Why use R?\n\nR is a powerful, extensible environment. It has a wide range of statistics and general data analysis and visualization capabilities.\n\nData handling, wrangling, and storage\nWide array of statistical methods and graphical techniques available\nEasy to install on any platform and use (and it’s free!)\nOpen source with a large and growing community of peers\n\n\nExamples of R used in the media and science\n\n“At the BBC data team, we have developed an R package and an R cookbook to make the process of creating publication-ready graphics in our in-house style…” - BBC Visual and Data Journalism cookbook for R graphics\n“R package of data and code behind the stories and interactives at FiveThirtyEight.com, a data-driven journalism website founded by Nate Silver (initially began as a polling aggregation site, but now covers politics, sports, science and pop culture) and owned by ESPN…” - fivethirtyeight Package\nSingle Cell RNA-seq Data analysis with Seurat"
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#what-is-rstudio",
    "href": "01_introR-R-and-RStudio.html#what-is-rstudio",
    "title": "Introduction to R and RStudio",
    "section": "What is RStudio?",
    "text": "What is RStudio?\nRStudio is freely available open-source Integrated Development Environment (IDE). RStudio provides an environment with many features to make using R easier and is a great alternative to working on R in the terminal.\n\n\nGraphical user interface, not just a command prompt\nGreat learning tool\nFree for academic use\nPlatform agnostic\nOpen source"
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#creating-a-new-project-directory-in-rstudio",
    "href": "01_introR-R-and-RStudio.html#creating-a-new-project-directory-in-rstudio",
    "title": "Introduction to R and RStudio",
    "section": "Creating a new project directory in RStudio",
    "text": "Creating a new project directory in RStudio\nLet’s create a new project directory for our “Introduction to R” lesson today.\n\nOpen RStudio\nGo to the File menu and select New Project.\nIn the New Project window, choose New Directory. Then, choose New Project. Name your new directory Intro-to-R and then “Create the project as subdirectory of:” the Desktop (or location of your choice).\nClick on Create Project.\n\n\n\nAfter your project is completed, if the project does not automatically open in RStudio, then go to the File menu, select Open Project, and choose Intro-to-R.Rproj.\nWhen RStudio opens, you will see three panels in the window.\nGo to the File menu and select New File, and select R Script.\nGo to the File menu and select Save As..., type Intro-to-R.R and select Save\n\n\n\n\nThe RStudio interface should now look like the screenshot below.\n\n\n\nRStudio interface\n\n\n\nWhat is a project in RStudio?\nIt is simply a directory that contains everything related your analyses for a specific project. RStudio projects are useful when you are working on context- specific analyses and you wish to keep them separate. When creating a project in RStudio you associate it with a working directory of your choice (either an existing one, or a new one). A . RProj file is created within that directory and that keeps track of your command history and variables in the environment. The . RProj file can be used to open the project in its current state but at a later date.\nWhen a project is (re) opened within RStudio the following actions are taken:\n\nA new R session (process) is started\nThe .RData file in the project’s main directory is loaded, populating the environment with any objects that were present when the project was closed.\nThe .Rhistory file in the project’s main directory is loaded into the RStudio History pane (and used for Console Up/Down arrow command history).\nThe current working directory is set to the project directory.\nPreviously edited source documents are restored into editor tabs\nOther RStudio settings (e.g. active tabs, splitter positions, etc.) are restored to where they were the last time the project was closed.\n\nInformation adapted from RStudio Support Site"
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#rstudio-interface",
    "href": "01_introR-R-and-RStudio.html#rstudio-interface",
    "title": "Introduction to R and RStudio",
    "section": "RStudio Interface",
    "text": "RStudio Interface\nThe RStudio interface has four main panels:\n\nConsole: where you can type commands and see output. The console is all you would see if you ran R in the command line without RStudio.\nScript editor: where you can type out commands and save to file. You can also submit the commands to run in the console.\nEnvironment/History: environment shows all active objects and history keeps track of all commands run in console\nFiles/Plots/Packages/Help"
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#organizing-your-working-directory-setting-up",
    "href": "01_introR-R-and-RStudio.html#organizing-your-working-directory-setting-up",
    "title": "Introduction to R and RStudio",
    "section": "Organizing your working directory & setting up",
    "text": "Organizing your working directory & setting up\n\nViewing your working directory\nBefore we organize our working directory, let’s check to see where our current working directory is located by typing into the console:\n\ngetwd()\n\n[1] \"/Users/nos491/Desktop/intro_r_rmd/lessons\"\n\n\nYour working directory should be the Intro-to-R folder constructed when you created the project. The working directory is where RStudio will automatically look for any files you bring in and where it will automatically save any files you create, unless otherwise specified.\nYou can visualize your working directory by selecting the Files tab from the Files/Plots/Packages/Help window.\n\n\n\nIf you wanted to choose a different directory to be your working directory, you could navigate to a different folder in the Files tab, then, click on the More dropdown menu which appears as a Cog and select Set As Working Directory.\n\n\n\n\n\nStructuring your working directory\nTo organize your working directory for a particular analysis, you should separate the original data (raw data) from intermediate datasets. For instance, you may want to create a data/ directory within your working directory that stores the raw data, and have a results/ directory for intermediate datasets and a figures/ directory for the plots you will generate.\n\n\n\nLet’s create these three directories within your working directory by clicking on New Folder within the Files tab.\nWhen finished, your working directory should look like:\n\n\n\n\n\nSetting up\nThis is more of a housekeeping task. We will be writing long lines of code in our script editor and want to make sure that the lines “wrap” and you don’t have to scroll back and forth to look at your long line of code.\nClick on “Code” at the top of your RStudio screen and select “Soft Wrap Long Lines” in the pull down menu."
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#interacting-with-r",
    "href": "01_introR-R-and-RStudio.html#interacting-with-r",
    "title": "Introduction to R and RStudio",
    "section": "Interacting with R",
    "text": "Interacting with R\nNow that we have our interface and directory structure set up, let’s start playing with R! There are two main ways of interacting with R in RStudio: using the console or by using script editor (plain text files that contain your code).\n\nConsole window\nThe console window (in RStudio, the bottom left panel) is the place where R is waiting for you to tell it what to do, and where it will show the results of a command. You can type commands directly into the console, but they will be forgotten when you close the session.\nLet’s test it out:\n\n3 + 5\n\n[1] 8\n\n\n\n\nScript editor\nBest practice is to enter the commands in the script editor, and save the script. You are encouraged to comment liberally to describe the commands you are running using #. This way, you have a complete record of what you did, you can easily show others how you did it and you can do it again later on if needed.\nThe Rstudio script editor allows you to ‘send’ the current line or the currently highlighted text to the R console by clicking on the Run button in the upper-right hand corner of the script editor.\nNow let’s try entering commands to the script editor and using the comments character # to add descriptions and highlighting the text to run:\n\n# Intro to R Lesson\n# Feb 16th, 2016\n\n# Interacting with R\n\n## I am adding 3 and 5. R is fun!\n3 + 5\n\n[1] 8\n\n\n\n\n\nAlternatively, you can run by simply pressing the Ctrl and Return/Enter keys at the same time as a shortcut.\n\n\n\nYou should see the command run in the console and output the result.\n\n\n\nWhat happens if we do that same command without the comment symbol #? Re-run the command after removing the # sign in the front:\n\nI am adding 3 and 5. R is fun!\n3+5\n\nNow R is trying to run that sentence as a command, and it doesn’t work. We get an error in the console\n\n\n\n\n\n\nWarning\n\n\n\nError: unexpected symbol in “I am”\n\n\nThis means that the R interpreter did not know what to do with that command\n\n\nConsole command prompt\nInterpreting the command prompt can help understand when R is ready to accept commands. Below lists the different states of the command prompt and how you can exit a command:\nConsole is ready to accept commands: &gt;.\nIf R is ready to accept commands, the R console shows a &gt; prompt.\nWhen the console receives a command (by directly typing into the console or running from the script editor (Ctrl-Enter), R will try to execute it.\nAfter running, the console will show the results and come back with a new &gt; prompt to wait for new commands.\nConsole is waiting for you to enter more data: +.\nIf R is still waiting for you to enter more data because it isn’t complete yet, the console will show a + prompt. It means that you haven’t finished entering a complete command. Often this can be due to you having not ‘closed’ a parenthesis or quotation.\nEscaping a command and getting a new prompt: esc\nIf you’re in Rstudio and you can’t figure out why your command isn’t running, you can click inside the console window and press esc to escape the command and bring back a new prompt &gt;.\n\n\nKeyboard shortcuts in RStudio\nIn addition to some of the shortcuts described earlier in this lesson, we have listed a few more that can be helpful as you work in RStudio.\n\n\n\n\n\n\n\nkey\naction\n\n\n\n\nCtrl+Enter\nRun command from script editor in console\n\n\nESC\nEscape the current command to return to the command prompt\n\n\nCtrl+1\nMove cursor from console to script editor\n\n\nCtrl+2\nMove cursor from script editor to console\n\n\nTab\nUse this key to complete a file path\n\n\nCtrl+Shift+C\nComment the block of highlighted text\n\n\n\n\n\n\n\n\n\nExercises\n\n\n\n\nTry highlighting only 3 + from your script editor and running it. Find a way to bring back the command prompt &gt; in the console."
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#the-r-syntax",
    "href": "01_introR-R-and-RStudio.html#the-r-syntax",
    "title": "Introduction to R and RStudio",
    "section": "The R syntax",
    "text": "The R syntax\nNow that we know how to talk with R via the script editor or the console, we want to use R for something more than adding numbers. To do this, we need to know more about the R syntax.\nThe main “parts of speech” in R (syntax) include:\n\nthe comments # and how they are used to document function and its content\nvariables and functions\nthe assignment operator &lt;-\nthe = for arguments in functions\n\nNOTE: indentation and consistency in spacing is used to improve clarity and legibility\nWe will go through each of these “parts of speech” in more detail, starting with the assignment operator."
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#assignment-operator",
    "href": "01_introR-R-and-RStudio.html#assignment-operator",
    "title": "Introduction to R and RStudio",
    "section": "Assignment operator",
    "text": "Assignment operator\nTo do useful and interesting things in R, we need to assign values to variables using the assignment operator, &lt;-. For example, we can use the assignment operator to assign the value of 3 to x by executing:\n\nx &lt;- 3\n\nThe assignment operator (&lt;-) assigns values on the right to variables on the left.\nIn RStudio, typing Alt + - (push Alt at the same time as the - key, on Mac type option + -) will write &lt;- in a single keystroke."
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#variables",
    "href": "01_introR-R-and-RStudio.html#variables",
    "title": "Introduction to R and RStudio",
    "section": "Variables",
    "text": "Variables\nA variable is a symbolic name for (or reference to) information. Variables in computer programming are analogous to “buckets”, where information can be maintained and referenced. On the outside of the bucket is a name. When referring to the bucket, we use the name of the bucket, not the data stored in the bucket.\nIn the example above, we created a variable or a ‘bucket’ called x. Inside we put a value, 3.\nLet’s create another variable called y and give it a value of 5.\n\ny &lt;- 5\n\nWhen assigning a value to an variable, R does not print anything to the console. You can force to print the value by using parentheses or by typing the variable name.\n\ny\n\n[1] 5\n\n\nYou can also view information on the variable by looking in your Environment window in the upper right-hand corner of the RStudio interface.\n\n\n\nNow we can reference these buckets by name to perform mathematical operations on the values contained within. What do you get in the console for the following operation:\n\nx + y\n\n[1] 8\n\n\nTry assigning the results of this operation to another variable called number.\n\nnumber &lt;- x + y\n\n\n\n\n\n\n\nExercises\n\n\n\n\nTry changing the value of the variable x to 5. What happens to number?\nNow try changing the value of variable y to contain the value 10. What do you need to do, to update the variable number?\n\n\n\n\nTips on variable names\nVariables can be given almost any name, such as x, current_temperature, or subject_id. However, there are some rules / suggestions you should keep in mind:\n\nMake your names explicit and not too long.\nAvoid names starting with a number (2x is not valid but x2 is)\nAvoid names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names (e.g., c, T, mean, data) as variable names. When in doubt check the help to see if the name is already in use.\nAvoid dots (.) within a variable name as in my.dataset. There are many functions in R with dots in their names for historical reasons, but because dots have a special meaning in R (for methods) and other programming languages, it’s best to avoid them.\nUse nouns for object names and verbs for function names\nKeep in mind that R is case sensitive (e.g., genome_length is different from Genome_length)\nBe consistent with the styling of your code (where you put spaces, how you name variable, etc.). In R, two popular style guides are Hadley Wickham’s style guide and Google’s."
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#interacting-with-data-in-r",
    "href": "01_introR-R-and-RStudio.html#interacting-with-data-in-r",
    "title": "Introduction to R and RStudio",
    "section": "Interacting with data in R",
    "text": "Interacting with data in R\nR is commonly used for handling big data, and so it only makes sense that we learn about R in the context of some kind of relevant data. Let’s take a few minutes to add files to the folders we created and familiarize ourselves with the data.\n\nAdding files to your working directory\nYou can access the files we need for this workshop using the links provided below. If you right click on the link, and “Save link as..”. Choose ~/Desktop/Intro-to-R/data as the destination of the file. You should now see the file appear in your working directory. We will discuss these files a bit later in the lesson.\n\nDownload the normalized counts file by right clicking on this link\nDownload metadata file using this link\nDownload the functional analysis output file using this link\n\n\nNOTE: If the files download automatically to some other location on your laptop, you can move them to the your working directory using your file explorer or finder (outside RStudio), or navigating to the files in the Files tab of the bottom right panel of RStudio\n\n\n\nThe dataset\nIn this example dataset, we have collected whole brain samples from 12 mice and want to evaluate expression differences between them. The expression data represents normalized count data obtained from RNA-sequencing of the 12 brain samples. This data is stored in a comma separated values (CSV) file as a 2-dimensional matrix, with each row corresponding to a gene and each column corresponding to a sample.\n\n\n\n\n\nThe metadata\nWe have another file in which we identify information about the data or metadata. Our metadata is also stored in a CSV file. In this file, each row corresponds to a sample and each column contains some information about each sample.\nThe first column contains the row names, and note that these are identical to the column names in our expression data file above (albeit, in a slightly different order). The next few columns contain information about our samples that allow us to categorize them. For example, the second column contains genotype information for each sample. Each sample is classified in one of two categories: Wt (wild type) or KO (knockout). What types of categories do you observe in the remaining columns?\n\n\n\nR is particularly good at handling this type of categorical data. Rather than simply storing this information as text, the data is represented in a specific data structure which allows the user to sort and manipulate the data in a quick and efficient manner. We will discuss this in more detail as we go through the different lessons in R!\n\n\nThe functional analysis results\nWe will be using the results of the functional analysis to learn about packages/functions from the Tidyverse suite of integrated packages. These packages are designed to work together to make common data science operations like data wrangling, tidying, reading/writing, parsing, and visualizing, more user-friendly."
  },
  {
    "objectID": "01_introR-R-and-RStudio.html#best-practices",
    "href": "01_introR-R-and-RStudio.html#best-practices",
    "title": "Introduction to R and RStudio",
    "section": "Best practices",
    "text": "Best practices\nBefore we move on to more complex concepts and getting familiar with the language, we want to point out a few things about best practices when working with R which will help you stay organized in the long run:\n\nCode and workflow are more reproducible if we can document everything that we do. Our end goal is not just to “do stuff”, but to do it in a way that anyone can easily and exactly replicate our workflow and results. All code should be written in the script editor and saved to file, rather than working in the console.\nThe R console should be mainly used to inspect objects, test a function or get help.\nUse # signs to comment. Comment liberally in your R scripts. This will help future you and other collaborators know what each line of code (or code block) was meant to do. Anything to the right of a # is ignored by R. A shortcut for this is Ctrl+Shift+C if you want to comment an entire chunk of text."
  }
]